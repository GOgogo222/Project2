## 12_21

**从这里开始：** https://www.bilibili.com/video/BV1et411b73Z?t=13.4&p=187

驯服VS Code：按 F6 编译且运行。。。

解决中文乱码问题：将UTF-8该为GBK，再按一下“Ctrl+Z”

**21**

构造函数

vector容器的语法：vector<类名> p；

往容器中插入数据：p.push_back(...);

迭代器遍历容器

函数的参数中的*，&，意味着“改变”

变量中的*，意味着“指针”

->：是专门为指针准备的


### string
---

**23**

string的本质是一个类，同时是一个char*型的容器

**24**

注意，string类型的变量（自定义类）之所以能像普通变量那样运算，是因为运算符重载，.assign是更为原始的函数实现方法

**赋值**
.assign(‘'hello world'’,5)：表示在“hello world”中取前五个字符，简述“hello world”中的前五个

.assidn(10,‘a’)：表示把‘a’字符取十个，简述10个‘a’

**25**

**附加**
str.append("game steam")函数方法  等价于=>  str += "game steam" 

**26**

**查找（find）**
.find(“”)：在字符串中查找，返回 **int** 类型值（从0开始）表示位置，没找到返回 **-1**

.rfind(“”)：从右往左找

**替换（replace）**
.replace(1,3,"1111") 表示从1号位置起三个字符 替换为 “1111”

**27**

**比较**
str1.compare(str2) == 0 : str1和str2是否相等

**28**

通过 **[]** 访问单个字符

.at(i) 等价于 => [i]

**29**

**插入**
.insert（1,"111"）在1号位置插入字符“111”

**删除**
.erase（1，3）擦去（删除）从1号位置开始的3个字符

**30**

**获取**
.substr(1,3) 获取从1号位置到3号位置的字串

**查找+获取**
.substr(0,str.find("@")) 一个查找+获取的实用案例

**总结**

来学几个新单词😀：
- 赋值（=）- **assign**
- 附加（+=）- **append**
- 查找（返回int数值）- f**ind / rfind**
- 替换（1,3,""）- **repalce**
- 比较（ = =，<，>） - **compare**
- 插入 - **insert**
- 删除 - **erase**
- 获取字符串 - **substr**

### vector
---

**31**

两个关键词 **单端，动态**
- 单端：类似于一个栈
- 动态：扩展是不是在原来的基础上开辟新空间，而是找一块更大的**新空间**

**首地址**
.begin()：第0号位置

**尾地址**
.end()：最后一个位置

**构造方式（已有v1的前提下）**
~~~
// 通过区间构造
vector<int>v2(v1.begin(),v1.end());
// n个elem值构造
vector<int>v2(10,1);
// 拷贝构造
vector<int>v2(v1);
~~~

**32**

**赋值**

~~~
vector<int>v2;
// 通过区间赋值
v2.assign(v1.begin(),v1.end());
// n个elem值赋值
v2.assign(10,1); 
~~~

**33**

判断是否为**空**
.empty()

**容量**
.capacity()

**大小**
.size()

注意区分容量和大小这两个概念（容量>=大小），说明vector容器总是容易有未使用的空间

**重新指定大小**
.resize()

分为重新指定的大小比原来长或短 **两种情况**


**34**

**尾插**
.push_back();

**尾删**
.pop_back()

**插入**
.insert(v1.begin(),100); 表示在第0号位置插入数值100

.insert(v1.begin(),int count,100); 表示在第0号位置插入count个100

**删除**
.erase(v1.begin()); 表示删除第0号位置的数据

.erase(v1.begin(),v1.end()); 区间清空

**插入和删除的参数是迭代器！！！**
**插入和删除的参数是迭代器！！！**
**插入和删除的参数是迭代器！！！**

**35**

**访问**
.at(i)  等价于=>  [i]

.front()  返回第一个元素
.back()  返回最后一个元素

**36**

**交换**
v1.swap(v2);  交换v1和v2

**巧用swap()可以收缩空间，可以避免vector容器过分地扩展容量**

**37**

~~~
// 一种统计vector容器开辟次数的方法
int num = 0;
int * p = NULL;
if(p != v[0])
{
	p = &v[0]; // 取地址
	num++;
}
~~~


**预留空间**

v.reserve(10000);

**reserve一下可以减少开辟空间的次数**


